---
layout: post
title: SPI Peripheral design in SystemVerilog
description: Simple SPI slave implementation in SystemVerilog that supports single-byte (8-bit) SPI communication. It is designed to work with SPI Mode 0 (CPOL = 0, CPHA = 0), and can be simulated using ModelSim and synthesized in Quartus.
skills: 
- Digital design
- SystemVerilog
- Intel Quartus
- Modelsim
- Serial Peripheral Interface (SPI)
- Communication protocol
main-image: /FSM.png
---

# SPI Peripheral Implementation in SystemVerilog

Welcome to my project blog on implementing a **Serial Peripheral Interface (SPI)** slave module from scratch using **SystemVerilog**. This project aims to demystify how SPI works under the hood by building the logic and simulating it without relying on high-level libraries.

📁 [Project GitHub Repository](https://github.com/mmzarif/spi_project)

---

## 🔧 Overview

**SPI** is a popular full-duplex, synchronous protocol widely used for communication between microcontrollers and peripherals like displays, sensors, and memory chips.

This project focuses on building the **Peripheral (Slave)** side of the SPI interface, covering:

- Manual signal control (MOSI, MISO, SCLK, CS)
- An FSM-based SPI slave design
- 8-bit data transfers (Mode 0 only)
- Simulation using ModelSim
- Synthesis using Quartus Prime

---

## 🧠 Key Concepts

| Signal | Description |
|--------|-------------|
| `MOSI` | Master Out, Slave In (input from controller) |
| `MISO` | Master In, Slave Out (output to controller) |
| `SCLK` | Clock generated by master |
| `CS`   | Chip select, active low |
| `DONE` | Output signal: goes high when 8-bit data transfer completes |
| `RECEIVED_DATA` | 8-bit register holding received byte |

---

## 🗂 Module Ports

```systemverilog
module spi_slave (
    input  logic clk,       // System clock
    input  logic rst,       // Reset signal
    input  logic sclk,      // SPI clock from master
    input  logic cs,        // Active-low chip select
    input  logic mosi,      // Data from master
    output logic miso,      // Data to master
    output logic done,      // Byte transfer complete
    output logic [7:0] received_data  // Captured data
);
```

---

## 🔄 FSM Transition Diagram

This design uses a **Moore-style FSM** with three states:

```
     +-------+       CS=0         +------------+      bit_count==7        +-------+
     | IDLE  | --------------->   | RECEIVING  |  --------------------->   | DONE  |
     +-------+                   +------------+                          +-------+
          ^                                                                  |
          |                              SCLK↑                               |
          +------------------------------------------------------------------+
```

---

## 🧪 Simulation

Simulation was performed using **ModelSim**. The testbench sends a single byte `0x3C` (binary `00111100`) to the slave.

![waveform](/waveform.png)

### Results:

- ✅ `received_data` matches expected output
- ✅ `done` asserted at correct timing
- ✅ CS held low during transaction
- ✅ SCLK frequency < CLK frequency

```tcl
# spi_slave_wave.do
vlog ../rtl/spi_slave.sv
vlog ../tb/spi_slave_tb.sv
vsim spi_slave_tb
add wave -position insertpoint sim:/spi_slave_tb/*
run 1000ns
wave zoom full
```

---

## 📌 Key Takeaways

- ✅ SPI peripheral implemented in RTL from scratch
- ✅ FSM logic verified via simulation and synthesis
- ✅ Practical foundation for understanding synchronous protocols

---

## 🧠 Why It Matters

Understanding and implementing SPI at the hardware level is essential for:

- Debugging complex systems
- Building efficient communication interfaces
- Mastering hardware description languages like SystemVerilog

---

**Author:** Mustahsin Zarif  
**Date:** August 2025

